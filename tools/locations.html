<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <title>Track Preview</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body, #map { width:100%; height:100%; margin:0; padding:0; background:#0f1117; color:#fff; font-family:-apple-system,BlinkMacSystemFont,"Helvetica Neue",Arial,sans-serif; }
    .panel { position:absolute; z-index:9999; left:12px; top:12px; background:rgba(15,15,15,0.7); border-radius:12px; padding:10px 14px; box-shadow:0 12px 32px rgba(0,0,0,0.6); font-size:13px; line-height:1.4; max-width:420px; backdrop-filter:blur(8px); color:#eee; user-select:none; transition:transform .22s ease, opacity .22s ease, max-height .22s ease, padding .22s ease; }
    .panel b { color:#fff; font-weight:600; font-size:13px; }
    .panel-header { display:flex; align-items:center; gap:8px; cursor:default; }
    .panel-title { display:flex; align-items:center; gap:8px; min-width:0; }
    .mini { font-size:11px; color:#9aa4af; padding:2px 6px; border-radius:999px; border:1px solid #2b3138; background:rgba(0,0,0,.25); white-space:nowrap; overflow:hidden; text-overflow:ellipsis; max-width:220px; }
    .toggle { margin-left:auto; border:1px solid #30363d; background:#11141a; color:#e6edf3; border-radius:8px; padding:4px 8px; cursor:pointer; font-size:12px; }
    .toggle:hover { background:#171b22; }
    .content { margin-top:8px; }
    .row { margin-top:8px; display:grid; gap:6px; }
    .row.inline { grid-template-columns: auto 1fr; align-items:center; }
    .row input[type="datetime-local"], .row input[type="color"]{ width:100%; box-sizing:border-box; border-radius:8px; border:1px solid #30363d; background:#0b0d12; color:#e6edf3; padding:6px 8px; }
    .btns { display:flex; gap:8px; margin-top:6px; }
    .btns button, .btns label.btn { flex:1; border:1px solid #30363d; background:#11141a; color:#e6edf3; border-radius:8px; padding:6px 10px; cursor:pointer; text-align:center; }
    .btns button:hover, .btns label.btn:hover { background:#171b22; }
    .muted { color:#aaa; }
    .dropzone { margin-top:8px; border:1px dashed #3a3f44; border-radius:10px; padding:8px; text-align:center; font-size:12px; color:#c9d1d9; background:rgba(13,15,22,0.5); transition:background .2s, border-color .2s; }
    .dropzone.dragover { border-color:#58a6ff; background:rgba(13,15,22,0.8); }
    .fileok { color:#59f; font-size:12px; word-break:break-all; }
    .error { color:#ff6b6b; font-size:12px; white-space:pre-wrap; }

    /* 顶部工具条（语言/主题） */
    .toolbar { position:absolute; right:12px; top:12px; z-index:10000; display:flex; gap:8px; align-items:center; background:rgba(15,15,15,0.7); padding:6px 10px; border-radius:10px; border:1px solid #2b3138; backdrop-filter:blur(8px); }
    .toolbar label { font-size:12px; color:#c9d1d9; }
    .toolbar select { background:#11141a; color:#e6edf3; border:1px solid #30363d; border-radius:8px; padding:4px 8px; }

    /* 加载遮罩 */
    .loading { position: fixed; inset: 0; display: none; align-items: center; justify-content: center; background: rgba(0,0,0,0.35); z-index: 99999; backdrop-filter: blur(2px); }
    .loading.show { display: flex; }
    .spinner { width: 56px; height: 56px; border-radius: 50%; border: 6px solid rgba(255,255,255,0.2); border-top-color: #58a6ff; animation: spin 0.9s linear infinite; }
    @keyframes spin { to { transform: rotate(360deg); } }
    .loading-text { margin-top: 12px; color: #c9d1d9; font-size: 12px; text-align: center; }

    /* 折叠态样式 */
    .panel.collapsed { padding:8px 10px; max-height:48px; overflow:hidden; }
    .panel.collapsed .content { display:none; }
    .opts { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .opts .seg { display:flex; gap:8px; align-items:center; }
    .opts label { display:flex; gap:6px; align-items:center; cursor:pointer; }
  </style>

  <!-- 内联语言清单（可改也可删除并改用 /languages.json） -->
  <script id="languages-json" type="application/json">
    [
      {"code":"zh-Hans","displayName":"简体中文"},
      {"code":"en","displayName":"English"}
    ]
  </script>

  <!-- sql.js（SQLite WASM） -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.10.2/sql-wasm.js"></script>

  <!-- 轻量：BMapGL 异步加载器（避免 document.write） -->
  <script>
    (function (g) {
      const DEFAULTS = { ak: "", v: "1.0", type: "webgl", timeout: 15000, retries: 1 };
      let _loading = null;
      function inject(src, onload, onerror) {
        const s = document.createElement("script");
        s.src = src; s.async = true; s.defer = true;
        s.onload = onload; s.onerror = onerror; document.head.appendChild(s);
      }
      function buildUrl({ ak, v, type, cb }) {
        const params = new URLSearchParams({ ak, v, type, callback: cb });
        return `https://api.map.baidu.com/api?${params}`;
      }
      function waitReady(timeout) {
        return new Promise((res, rej) => {
          const t = setTimeout(() => rej(new Error("BMapGL load timeout")), timeout);
          (function tick(){ if (g.BMapGL && g.BMapGL.Map){ clearTimeout(t); res(); } else { requestAnimationFrame(tick); } })();
        });
      }
      function loadOnce(opts) {
        const cfg = Object.assign({}, DEFAULTS, opts || {});
        if (!cfg.ak) return Promise.reject(new Error("Missing Baidu Map AK"));
        if (_loading) return _loading;
        _loading = new Promise((resolve, reject) => {
          let tries = 0;
          const cb = "__BMAPGL_CB_" + Math.random().toString(36).slice(2);
          g[cb] = function () {};
          const attempt = () => {
            tries++;
            inject(
              buildUrl({ ak: cfg.ak, v: cfg.v, type: cfg.type, cb }),
              () => {
                waitReady(cfg.timeout).then(resolve).catch(err => {
                  if (tries <= cfg.retries + 1) attempt(); else reject(err);
                });
              },
              () => { if (tries <= cfg.retries + 1) attempt(); else reject(new Error("Failed to load Baidu Map GL")); }
            );
          };
          attempt();
        });
        return _loading;
      }
      g.loadBMapGL = loadOnce;
    })(window);
  </script>

  <!-- 默认内联数据（可替换为你的点） -->
  <script id="trackData" type="application/json">[]</script>
</head>
<body>
<!-- 顶部工具条：语言切换 -->
<div class="toolbar" role="group" aria-label="toolbar">
  <label for="lang-switcher" data-i18n="tools.header.lang">语言</label>
  <select id="lang-switcher" aria-label="language switcher"></select>
</div>

<div id="map"></div>

<div class="panel" id="infoPanel">
  <div class="panel-header" data-i18n-title="tools.locations.panelHeaderTooltip" title="">
    <div class="panel-title">
      <b data-i18n="tools.locations.panelTitle">轨迹点预览</b>
      <span id="miniStats" class="mini">—</span>
    </div>
    <button id="togglePanel" class="toggle" aria-expanded="false" data-i18n="tools.locations.fold">收起</button>
  </div>

  <div class="content">
    <div class="row">
      <div class="btns">
        <label class="btn" for="fileInput" data-i18n="tools.locations.chooseFile">选择文件（.json / .db / .sqlite / .csv / .gpx / .kml）</label>
      </div>
      <input id="fileInput" type="file"
             accept=".json,application/json,.db,.sqlite,application/octet-stream,.csv,text/csv,.gpx,application/gpx+xml,.kml,application/vnd.google-earth.kml+xml"
             style="display:none" />
      <div class="dropzone" id="dropzone" data-i18n="tools.locations.dropHint">拖拽 JSON / SQLite / CSV / GPX / KML 文件到这里加载</div>
      <div class="muted" data-i18n="tools.locations.hintFormats">
        JSON/CSV：需要时间与经纬度；GPX/KML 自动识别；SQLite 自动探测表与列。坐标默认 WGS84；若含 gcj02* 或 isMarsLocation 则按 GCJ-02。
      </div>
      <div id="fileStatus" class="fileok" style="display:none;"></div>
      <div id="fileError" class="error" style="display:none;"></div>
    </div>

    <div class="row">
      <label data-i18n="tools.locations.timeSegmentLabel">时间片段（本地时区）：</label>
      <input id="startInput" type="datetime-local" step="1" />
      <input id="endInput" type="datetime-local" step="1" />
      <div class="btns">
        <button id="applyBtn" data-i18n="tools.locations.apply">应用筛选</button>
        <button id="resetBtn" title="" data-i18n="tools.locations.reset">重置</button>
      </div>
    </div>

    <div class="row">
      <div class="opts">
        <div class="seg">
          <label><input type="checkbox" id="optShowPoints" checked> <span data-i18n="tools.locations.showPoints">显示点</span></label>
          <label><input type="checkbox" id="optShowLine"> <span data-i18n="tools.locations.connectLine">连成线</span></label>
        </div>
        <div class="seg">
          <span data-i18n="tools.locations.color">颜色</span>
          <input type="color" id="pointColor" value="#5ab1ff" style="width:48px; height:32px; padding:0; border-radius:8px;">
        </div>
      </div>
      <div class="muted" data-i18n="tools.locations.bigDataHint">≥1000 点优先使用 PointCollection；不可用则回退 Canvas。超大数据量时会限制折线。</div>
    </div>

    <div class="row">
      <div id="statsCount">-</div>
      <div id="statsRange">-</div>
    </div>
  </div>
</div>

<div id="loading" class="loading" aria-live="polite" aria-busy="true">
  <div>
    <div class="spinner"></div>
    <div id="loadingText" class="loading-text">Loading…</div>
  </div>
</div>

<script>
  /************ i18n：极简本地化（支持 /i18n/ 与内联语言清单） ************/
  const I18N_DIR        = "/i18n";
  const FALLBACK_CODE   = "en";
  const STORAGE_KEY     = "timetrails.lang";
  let LANGUAGES = [];             // [{code, displayName}]
  let currentLang = FALLBACK_CODE;
  let dict = {};                  // 当前词典
  let dictFallback = {};          // 英文回退

  const qs  = (s, r = document) => r.querySelector(s);
  const qsa = (s, r = document) => Array.from(r.querySelectorAll(s));

  async function fetchJson(url) {
    const res = await fetch(url, { cache: "no-store" });
    if (!res.ok) throw new Error(`Fetch failed: ${url} ${res.status}`);
    return res.json();
  }
  async function loadLanguagesList() {
    // 优先从内联 script 读取
    const inline = qs("#languages-json");
    if (inline) {
      try { return JSON.parse(inline.textContent.trim() || "[]"); }
      catch(e){ console.warn("Inline languages-json parse failed:", e); }
    }
    // 回退从 /languages.json 获取
    try { return await fetchJson("/languages.json"); }
    catch(e){ console.warn("No /languages.json, fallback to en only."); return [{ code:"en", displayName:"English" }]; }
  }
  async function loadDict(code) {
    if (!Object.keys(dictFallback).length) {
      try { dictFallback = await fetchJson(`${I18N_DIR}/${FALLBACK_CODE}.json`); }
      catch(e){ console.error("[i18n] Fallback(en) dict load failed:", e); dictFallback = {}; }
    }
    try { return await fetchJson(`${I18N_DIR}/${code}.json`); }
    catch(e){ console.warn(`[i18n] ${code} missing, fallback to ${FALLBACK_CODE}`); return dictFallback; }
  }
  function getNested(obj, path) {
    return path.split(".").reduce((o, k) => (o && o[k] != null ? o[k] : undefined), obj);
  }
  function t(key, vars) {
    let txt = getNested(dict, key);
    if (txt == null) txt = getNested(dictFallback, key) ?? key;
    if (vars && typeof txt === "string") {
      for (const k in vars) txt = txt.replace(new RegExp(`\\{${k}\\}`, "g"), String(vars[k]));
    }
    return txt;
  }
  function applyI18nToDOM() {
    // 普通文本
    qsa("[data-i18n]").forEach(el => {
      const key = el.getAttribute("data-i18n");
      el.textContent = t(key);
    });
    // title/placeholder 等属性型
    qsa("[data-i18n-title]").forEach(el => {
      const key = el.getAttribute("data-i18n-title");
      el.title = t(key);
    });
    qsa("[data-i18n-ph]").forEach(el => {
      const key = el.getAttribute("data-i18n-ph");
      el.placeholder = t(key);
    });
    document.documentElement.setAttribute("lang", currentLang);
    document.title = t("tools.locations.pageTitle");
    qs("#loadingText").textContent = t("tools.locations.loading");
    // 折叠按钮文案根据状态处理
    const btn = qs("#togglePanel");
    if (btn) btn.textContent = qs("#infoPanel").classList.contains("collapsed") ? t("tools.locations.unfold") : t("tools.locations.fold");
  }
  function detectInitialLang() {
    const url = new URL(location.href);
    const fromQuery = url.searchParams.get("lang");
    const fromStore = localStorage.getItem(STORAGE_KEY);
    const browser = (navigator.language || "").toLowerCase();
    const candidates = [fromStore, fromQuery, browser, FALLBACK_CODE].filter(Boolean);
    for (const c of candidates) {
      const exact = LANGUAGES.find(l => l.code.toLowerCase() === c.toLowerCase());
      if (exact) return exact.code;
      const base = c.split("-")[0];
      const baseHit = LANGUAGES.find(l => l.code.toLowerCase() === base);
      if (baseHit) return baseHit.code;
    }
    return FALLBACK_CODE;
  }
  function populateLangSwitcher() {
    const sel = qs("#lang-switcher"); if (!sel) return;
    sel.innerHTML = "";
    LANGUAGES.forEach(({ code, displayName }) => {
      const opt = document.createElement("option");
      opt.value = code; opt.textContent = displayName || code; sel.appendChild(opt);
    });
    sel.value = currentLang;
    sel.addEventListener("change", async () => { await setLanguage(sel.value); });
  }
  async function setLanguage(code) {
    currentLang = code; localStorage.setItem(STORAGE_KEY, code);
    dict = await loadDict(code);
    applyI18nToDOM();
    const url = new URL(location.href);
    url.searchParams.set("lang", code);
    history.replaceState({}, "", url.toString());
  }
  // 启动 i18n
  (async function initI18n(){
    LANGUAGES = await loadLanguagesList();
    currentLang = detectInitialLang();
    await setLanguage(currentLang);
    populateLangSwitcher();
  })();

  /************ 小工具（与地图无关） ************/
  function showLoading(msg){ const el=qs("#loading"); qs("#loadingText").textContent= msg || t("tools.locations.loading"); el.classList.add("show"); }
  function hideLoading(){ qs("#loading").classList.remove("show"); }
  const pad2=n=>n<10?('0'+n):''+n;
  function tsToLocal(ts){const d=new Date(ts);return `${d.getFullYear()}-${pad2(d.getMonth()+1)}-${pad2(d.getDate())} ${pad2(d.getHours())}:${pad2(d.getMinutes())}:${pad2(d.getSeconds())}`;}
  function tsToLocalInput(ts){const d=new Date(ts);return `${d.getFullYear()}-${pad2(d.getMonth()+1)}-${pad2(d.getDate())}T${pad2(d.getHours())}:${pad2(d.getMinutes())}:${pad2(d.getSeconds())}`;}
  function inputToTs(val){ if(!val) return null; const t=new Date(val).getTime(); return Number.isFinite(t)?t:null; }
  const num = x => (x==null || x==="") ? NaN : Number(x);

  /************ 主应用逻辑：等 BMapGL 就绪后再执行 ************/
  function runApp() {
    // —— 坐标转换 —— //
    function _outOfChina(lng, lat){return(lng<72.004||lng>137.8347||lat<0.8293||lat>55.8271);}
    function _transformLat(lng,lat){let ret=-100+2*lng+3*lat+0.2*lat*lat+0.1*lng*lat+0.2*Math.sqrt(Math.abs(lng));ret+=(20*Math.sin(6*lng*Math.PI)+20*Math.sin(2*lng*Math.PI))*2/3;ret+=(20*Math.sin(lat*Math.PI)+40*Math.sin(lat/3*Math.PI))*2/3;ret+=(160*Math.sin(lat/12*Math.PI)+320*Math.sin(lat*Math.PI/30))*2/3;return ret;}
    function _transformLng(lng,lat){let ret=300+lng+2*lat+0.1*lng*lng+0.1*lng*lat+0.1*Math.sqrt(Math.abs(lng));ret+=(20*Math.sin(6*lng*Math.PI)+20*Math.sin(2*lng*Math.PI))*2/3;ret+=(20*Math.sin(lng*Math.PI)+40*Math.sin(lng/3*Math.PI))*2/3;ret+=(150*Math.sin(lng/12*Math.PI)+300*Math.sin(lng/30*Math.PI))*2/3;return ret;}
    function wgs84ToGcj02(lng,lat){ if(_outOfChina(lng,lat)) return [lng,lat]; const a=6378245.0,ee=0.00669342162296594323; let dLat=_transformLat(lng-105,lat-35), dLng=_transformLng(lng-105,lat-35); const radLat=lat/180*Math.PI; let magic=Math.sin(radLat); magic=1-ee*magic*magic; const sqrtMagic=Math.sqrt(magic); dLat=(dLat*180)/((a*(1-ee))/(magic*sqrtMagic)*Math.PI); dLng=(dLng*180)/(a/sqrtMagic*Math.cos(radLat)*Math.PI); return [lng+dLng, lat+dLat];}
    function gcj02ToBd09(lng,lat){const x=lng,y=lat; const z=Math.sqrt(x*x+y*y)+0.00002*Math.sin(y*Math.PI*3000/180); const th=Math.atan2(y,x)+0.000003*Math.cos(x*Math.PI*3000/180); return [z*Math.cos(th)+0.0065, z*Math.sin(th)+0.006];}
    function wgs84ToBd09(lng,lat){const [glng,glat]=wgs84ToGcj02(lng,lat); return gcj02ToBd09(glng,glat);}

    // —— 解析 —— //
    function parseTsFlexible(p){
      if (Number.isFinite(p.ts)) return p.ts<1e12?p.ts*1000:p.ts;
      if (Number.isFinite(p.timestamp)) return p.timestamp<1e12?p.timestamp*1000:p.timestamp;
      if (p.time_ms && Number.isFinite(p.time_ms)) return Number(p.time_ms);
      if (p.time && Number.isFinite(p.time)) return (p.time<1e12? p.time*1000 : p.time);
      if (typeof p.timeString === 'string'){ const d=new Date(p.timeString.replace(" ","T")); const t=d.getTime(); if(Number.isFinite(t)) return t; }
      if (typeof p.datetime === 'string'){ const t=new Date(p.datetime).getTime(); if (Number.isFinite(t)) return t; }
      if (typeof p.date === 'string'){ const t=new Date(p.date).getTime(); if (Number.isFinite(t)) return t; }
      return NaN;
    }
    function pickDegFlexible(p){
      if (Number.isFinite(p.latitude) && Number.isFinite(p.longitude)) return {lng:+p.longitude, lat:+p.latitude, gcj:false};
      if (Number.isFinite(p.gcj02latitude) && Number.isFinite(p.gcj02longitude)) return {lng:+p.gcj02longitude, lat:+p.gcj02latitude, gcj:true};
      if (Number.isFinite(p.lon_e6) && Number.isFinite(p.lat_e6)) return {lng:p.lon_e6/1e6, lat:p.lat_e6/1e6, gcj:false};
      if (Number.isFinite(p.lat) && Number.isFinite(p.lon)) return {lng:+p.lon, lat:+p.lat, gcj:false};
      if (Number.isFinite(p.lng) && Number.isFinite(p.lat)) return {lng:+p.lng, lat:+p.lat, gcj:false};
      return null;
    }
    function splitCSVLine(line){
      const out=[]; let cur=''; let inQ=false;
      for (let i=0;i<line.length;i++){
        const ch=line[i];
        if (ch==='\"'){ if (inQ && line[i+1]==='\"'){ cur+='\"'; i++; } else inQ=!inQ; }
        else if (ch===',' && !inQ){ out.push(cur); cur=''; }
        else { cur+=ch; }
      }
      out.push(cur);
      return out.map(s=>s.trim());
    }
    function parseCSV(text){
      const lines=text.replace(/\r\n?/g,'\n').split('\n').filter(l=>l.trim().length>0);
      if (lines.length===0) return [];
      const header=splitCSVLine(lines[0]).map(h=>h.trim().toLowerCase());
      const idx = nameList=>{
        for (const n of nameList){ const k=n.toLowerCase(); const j=header.indexOf(k); if (j>=0) return j; }
        return -1;
      };
      const tidx=idx(['timestamp','time_ms','time','ts','times','datetime','date','timestring']);
      const lonIdx=idx(['longitude','lon','lng','lon_e6']);
      const latIdx=idx(['latitude','lat','lat_e6']);
      const gcjIdx=idx(['ismarslocation','gcj','gcj02','is_gcj']);
      const out=[];
      for (let i=1;i<lines.length;i++){
        const cols=splitCSVLine(lines[i]);
        const lonRaw = lonIdx>=0? cols[lonIdx] : null;
        const latRaw = latIdx>=0? cols[latIdx] : null;
        if (lonRaw==null || latRaw==null) continue;
        const lonV = num(lonRaw), latV = num(latRaw);
        let ts = NaN;
        if (tidx>=0){
          const tv = cols[tidx];
          const n = Number(tv);
          if (Number.isFinite(n)) ts = (n<1e12 ? n*1000 : n);
          else{
            const t2=new Date(String(tv).replace(' ','T')).getTime();
            if (Number.isFinite(t2)) ts=t2;
          }
        }
        if (!Number.isFinite(ts)) ts = Date.now() + i;
        const useDeg = Math.abs(lonV)<=180 && Math.abs(latV)<=90;
        const obj = useDeg ? { ts, longitude: lonV, latitude: latV } : { ts, lon_e6: Math.round(lonV), lat_e6: Math.round(latV) };
        if (gcjIdx>=0){
          const flag=cols[gcjIdx]; const b = String(flag).trim();
          if (b==='1' || /^true$/i.test(b)) obj.gcj = true;
        }
        out.push(obj);
      }
      return out;
    }
    function parseGPX(text){
      const doc = new DOMParser().parseFromString(text, 'application/xml');
      const out=[];
      const pick = (el)=>el ? el.textContent.trim() : '';
      const trkpts = Array.from(doc.getElementsByTagName('trkpt'));
      for (const p of trkpts){
        const lat = num(p.getAttribute('lat'));
        const lon = num(p.getAttribute('lon'));
        const t = pick(p.getElementsByTagName('time')[0]||null);
        const ts = Number.isFinite(Number(t)) ? (Number(t)<1e12?Number(t)*1000:Number(t)) : new Date(t).getTime();
        const tsFinal = Number.isFinite(ts)? ts : (Date.now()+out.length);
        if (Number.isFinite(lat) && Number.isFinite(lon)) out.push({ ts: tsFinal, latitude: lat, longitude: lon });
      }
      const wpts = Array.from(doc.getElementsByTagName('wpt'));
      for (const p of wpts){
        const lat = num(p.getAttribute('lat'));
        const lon = num(p.getAttribute('lon'));
        const tEl = p.getElementsByTagName('time')[0]||null;
        const t = tEl ? tEl.textContent.trim() : '';
        const ts = Number.isFinite(Number(t)) ? (Number(t)<1e12?Number(t)*1000:Number(t)) : new Date(t).getTime();
        const tsFinal = Number.isFinite(ts)? ts : (Date.now()+out.length);
        if (Number.isFinite(lat) && Number.isFinite(lon)) out.push({ ts: tsFinal, latitude: lat, longitude: lon });
      }
      return out;
    }
    function parseKML(text){
      const doc = new DOMParser().parseFromString(text, 'application/xml');
      const out=[];
      const txt = el=> (el? el.textContent.trim() : '');
      const tracks = doc.getElementsByTagNameNS('*','Track');
      for (const trk of tracks){
        const when = Array.from(trk.getElementsByTagName('when')).map(e=>txt(e));
        const coords = Array.from(trk.getElementsByTagNameNS('*','coord')).map(e=>txt(e));
        const m = Math.min(when.length, coords.length);
        for (let i=0;i<m;i++){
          const ts = new Date(when[i]).getTime();
          const parts = coords[i].split(/\s+/).map(Number);
          const lon=parts[0], lat=parts[1];
          if (Number.isFinite(lon)&&Number.isFinite(lat)){
            const tsFinal = Number.isFinite(ts)?ts:(Date.now()+out.length);
            out.push({ ts: tsFinal, longitude: lon, latitude: lat });
          }
        }
      }
      const lines = doc.getElementsByTagName('LineString');
      for (const ls of lines){
        const coordNode = ls.getElementsByTagName('coordinates')[0];
        if (!coordNode) continue;
        const list = coordNode.textContent.trim().split(/\s+/);
        for (let i=0;i<list.length;i++){
          const parts = list[i].split(',').map(Number);
          const lon=parts[0], lat=parts[1];
          if (Number.isFinite(lon)&&Number.isFinite(lat)){
            out.push({ ts: Date.now()+out.length, longitude: lon, latitude: lat });
          }
        }
      }
      const points = doc.getElementsByTagName('Point');
      for (const pt of points){
        const coordNode = pt.getElementsByTagName('coordinates')[0];
        if (!coordNode) continue;
        const parts = coordNode.textContent.trim().split(',').map(Number);
        const lon=parts[0], lat=parts[1];
        if (Number.isFinite(lon)&&Number.isFinite(lat)){
          out.push({ ts: Date.now()+out.length, longitude: lon, latitude: lat });
        }
      }
      return out;
    }

    // —— 全局状态 —— //
    let map=null;
    let rawTrack=[]; // { ts(ms), lon_e6, lat_e6, __gcj? }
    let minTs=null, maxTs=null;
    let bigLayer=null, smallMarkers=[];
    let canvasLayer=null; // Canvas 点
    let lineLayer=null;   // 折线
    window.__TT_SQLDB__=null;

    const MAX_LINE_POINTS = 50000;

    function getPointConsts(){
      const sizeSmall = (window.BMAP_POINT_SIZE_SMALL!==undefined) ? window.BMAP_POINT_SIZE_SMALL
                        : (BMapGL && BMapGL.PointSizeType && BMapGL.PointSizeType.SMALL) || 1;
      const shapeCircle = (window.BMAP_POINT_SHAPE_CIRCLE!==undefined) ? window.BMAP_POINT_SHAPE_CIRCLE
                        : (BMapGL && BMapGL.PointShapeType && BMapGL.PointShapeType.CIRCLE) || 0;
      const hasPC = !!(BMapGL && typeof BMapGL.PointCollection === 'function');
      return { sizeSmall, shapeCircle, hasPC };
    }

    class CanvasDots extends BMapGL.Overlay {
      constructor(points, color='#5ab1ff', radius=2){ super(); this.points=points; this.color=color; this.radius=radius; this._map=null; this._canvas=null; this._ctx=null; this._bindedDraw=this.draw.bind(this); }
      initialize(map){
        this._map=map;
        const canvas=this._canvas=document.createElement('canvas');
        canvas.style.position='absolute'; canvas.style.left=0; canvas.style.top=0; canvas.style.pointerEvents='none';
        this._ctx=canvas.getContext('2d');
        map.getPanes().labelPane.appendChild(canvas);
        map.addEventListener('zoomend', this._bindedDraw);
        map.addEventListener('moveend', this._bindedDraw);
        map.addEventListener('resize', this._bindedDraw);
        this._syncSize();
        return canvas;
      }
      _syncSize(){
        const sz=this._map.getSize();
        const ratio=window.devicePixelRatio||1;
        this._canvas.width=Math.round(sz.width*ratio);
        this._canvas.height=Math.round(sz.height*ratio);
        this._canvas.style.width=sz.width+'px';
        this._canvas.style.height=sz.height+'px';
        this._ctx.setTransform(ratio,0,0,ratio,0,0);
      }
      draw(){
        if (!this._map || !this._ctx) return;
        this._syncSize();
        const ctx=this._ctx; const radius=this.radius;
        ctx.clearRect(0,0,this._canvas.width,this._canvas.height);
        ctx.fillStyle=this.color;
        const bounds=this._map.getBounds();
        for (let i=0;i<this.points.length;i++){
          const p=this.points[i];
          if (!bounds.containsPoint(p)) continue;
          const pix=this._map.pointToPixel(p);
          ctx.beginPath();
          ctx.arc(pix.x, pix.y, radius, 0, Math.PI*2);
          ctx.fill();
        }
      }
      setPoints(points){ this.points=points||[]; this.draw(); }
      setStyle({color, radius}){ if (color) this.color=color; if (radius) this.radius=radius; this.draw(); }
      remove(){
        if (!this._map) return;
        this._map.removeEventListener('zoomend', this._bindedDraw);
        this._map.removeEventListener('moveend', this._bindedDraw);
        this._map.removeEventListener('resize', this._bindedDraw);
        if (this._canvas && this._canvas.parentNode) this._canvas.parentNode.removeChild(this._canvas);
        this._canvas=null; this._ctx=null; this._map=null;
      }
    }

    function clearOverlays(){
      if (bigLayer){ map.removeOverlay(bigLayer); bigLayer=null; }
      if (canvasLayer){ map.removeOverlay(canvasLayer); canvasLayer.remove?.(); canvasLayer=null; }
      if (lineLayer){ map.removeOverlay(lineLayer); lineLayer=null; }
      if (smallMarkers.length){ for (const m of smallMarkers) map.removeOverlay(m); smallMarkers.length=0; }
    }

    function renderUnified(arr){
      clearOverlays();
      const showPoints = qs('#optShowPoints').checked;
      const showLine   = qs('#optShowLine').checked;
      const colorHex   = qs('#pointColor').value || '#5ab1ff';

      if (!arr || arr.length===0){
        map.centerAndZoom(new BMapGL.Point(116.404,39.915),12);
        qs("#statsCount").textContent = t("tools.locations.statsCount", { count: 0 });
        qs("#statsRange").textContent = t("tools.locations.statsRange", { start: "—", end: "—" });
        qs("#miniStats").textContent  = t("tools.locations.miniStats", { count: 0, start: "—", end: "—" });
        hideLoading(); return;
      }

      // 转 BD09
      const pts=[];
      for (const p of arr){
        const lng=p.lon_e6/1e6, lat=p.lat_e6/1e6;
        let bdLng, bdLat;
        if (p.__gcj===true){ [bdLng,bdLat]=gcj02ToBd09(lng,lat); }
        else { [bdLng,bdLat]=wgs84ToBd09(lng,lat); }
        pts.push(new BMapGL.Point(bdLng,bdLat));
      }
      try{ map.setViewport(pts); }catch(_){}

      const { sizeSmall, shapeCircle, hasPC } = getPointConsts();

      // 折线
      if (showLine && pts.length>=2){
        if (pts.length <= MAX_LINE_POINTS){
          lineLayer = new BMapGL.Polyline(pts, { strokeColor: colorHex, strokeWeight: 3, strokeOpacity: 0.9 });
          map.addOverlay(lineLayer);
        } else {
          const fe=qs("#fileStatus");
          fe.style.display="block";
          fe.textContent=t("tools.locations.skipPolyline", { n: pts.length, limit: MAX_LINE_POINTS });
        }
      }

      // 点
      if (showPoints){
        if (arr.length < 1000){
          const dots = new CanvasDots(pts, colorHex, 2.5);
          map.addOverlay(dots); canvasLayer = dots;

          const first = new BMapGL.Marker(pts[0]); first.setTitle(t("tools.locations.startPoint")); map.addOverlay(first); smallMarkers.push(first);
          const firstLabel=new BMapGL.Label(t("tools.locations.startPoint"),{position:pts[0],offset:new BMapGL.Size(10,-20)});
          firstLabel.setStyle({color:"#00E0FF",backgroundColor:"rgba(0,0,0,0.6)",border:"1px solid #00E0FF",borderRadius:"6px",padding:"2px 4px",fontSize:"12px",lineHeight:"14px"});
          map.addOverlay(firstLabel); smallMarkers.push(firstLabel);

          if (pts.length>=2){
            const last = new BMapGL.Marker(pts[pts.length-1]); last.setTitle(t("tools.locations.endPoint")); map.addOverlay(last); smallMarkers.push(last);
            const lastLabel=new BMapGL.Label(t("tools.locations.endPoint"),{position:pts[pts.length-1],offset:new BMapGL.Size(10,-20)});
            lastLabel.setStyle({color:"#FF4D4F",backgroundColor:"rgba(0,0,0,0.6)",border:"1px solid #FF4D4F",borderRadius:"6px",padding:"2px 4px",fontSize:"12px",lineHeight:"14px"});
            map.addOverlay(lastLabel); smallMarkers.push(lastLabel);
          }
        } else if (hasPC && sizeSmall!=null && shapeCircle!=null){
          const opts = { size: sizeSmall, shape: shapeCircle, color: colorHex };
          const pc = new BMapGL.PointCollection(pts, opts);
          pc.addEventListener('click', e=>{
            const idx=e.index!=null?e.index:null;
            if (idx!=null && arr[idx]){
              const lbl=new BMapGL.Label(tsToLocal(arr[idx].ts), { position: e.point, offset:new BMapGL.Size(10,-20) });
              lbl.setStyle({color:"#fff",backgroundColor:"rgba(0,0,0,0.6)",border:"1px solid #30363d",borderRadius:"6px",padding:"2px 4px",fontSize:"12px",lineHeight:"14px"});
              map.addOverlay(lbl); setTimeout(()=>map.removeOverlay(lbl), 1200);
            }
          });
          map.addOverlay(pc); bigLayer = pc;
        } else {
          const dots = new CanvasDots(pts, colorHex, 2);
          map.addOverlay(dots); canvasLayer = dots;
        }
      }

      const count=arr.length, startTxt= tsToLocal(arr[0].ts), endTxt= tsToLocal(arr[count-1].ts);
      qs("#statsCount").textContent = t("tools.locations.statsCount", { count });
      qs("#statsRange").textContent = t("tools.locations.statsRange", { start: startTxt, end: endTxt });
      qs("#miniStats").textContent  = t("tools.locations.miniStats", { count, start: startTxt, end: endTxt });

      hideLoading();
    }

    function applyFilter_JSON(){
      showLoading(t("tools.locations.loadingFilter"));
      requestAnimationFrame(()=>{
        const sTs=inputToTs(qs("#startInput").value);
        const eTs=inputToTs(qs("#endInput").value);
        const s=(sTs==null)?minTs:sTs;
        const e=(eTs==null)?maxTs:eTs;
        if (s>e){ alert(t("tools.locations.errStartAfterEnd")); hideLoading(); return; }
        const arr=rawTrack.filter(p=>p.ts>=s&&p.ts<=e);
        renderUnified(arr);
      });
    }

    function applyFilter_DB(){
      const sess=window.__TT_SQLDB__; if (!sess){ applyFilter_JSON(); return; }
      showLoading(t("tools.locations.loadingDB"));
      requestAnimationFrame(()=>{
        const sTs=inputToTs(qs("#startInput").value);
        const eTs=inputToTs(qs("#endInput").value);
        const s=(sTs==null)?minTs:sTs, e=(eTs==null)?maxTs:eTs;
        if (s>e){ alert(t("tools.locations.errStartAfterEnd")); hideLoading(); return; }

        const { db, table, tsCol, lonCol, latCol, gcjLatCol, gcjLonCol, isMarsCol, tsIsMs } = sess;
        const qS = tsIsMs ? Math.floor(s) : Math.floor(s/1000);
        const qE = tsIsMs ? Math.floor(e) : Math.floor(e/1000);

        const sel = [
          `${tsCol} AS _ts`,
          `${lonCol} AS _lon`,
          `${latCol} AS _lat`,
          gcjLatCol ? `${gcjLatCol} AS _gclat` : null,
          gcjLonCol ? `${gcjLonCol} AS _gclon` : null,
          isMarsCol ? `${isMarsCol} AS _ismars` : null
        ].filter(Boolean).join(", ");
        const sql=`SELECT ${sel} FROM ${table} WHERE ${tsCol} BETWEEN ? AND ? ORDER BY ${tsCol} ASC;`;

        let stmt;
        try{
          stmt = db.prepare(sql); stmt.bind([qS,qE]);
          const arr=[];
          while (stmt.step()){
            const row=stmt.getAsObject();
            const ts = tsIsMs ? Number(row._ts) : Number(row._ts)*1000;
            const lon=Number(row._lon), lat=Number(row._lat);
            const looksDeg=Number.isFinite(lon)&&Number.isFinite(lat)&&Math.abs(lon)<=180&&Math.abs(lat)<=90;
            const lon_e6=looksDeg?Math.round(lon*1e6):Math.round(lon);
            const lat_e6=looksDeg?Math.round(lat*1e6):Math.round(lat);
            let isGcj=false;
            if (typeof row._ismars!=="undefined" && Number(row._ismars)===1) isGcj=true;
            else if (typeof row._gclat!=="undefined" && typeof row._gclon!=="undefined"){
              const glat=Number(row._gclat), glon=Number(row._gclon);
              if (Number.isFinite(glat)&&Number.isFinite(glon)) isGcj=true;
            }
            arr.push({ ts, lon_e6, lat_e6, __gcj:isGcj });
          }
          stmt.free();
          renderUnified(arr);
        }catch(err){
          if (stmt) try{ stmt.free(); }catch(_){}
          const fe=qs("#fileError"); fe.style.display="block"; fe.textContent=`${t("tools.locations.errSQLiteQuery", { msg: err.message })}`;
          console.error(err); renderUnified([]);
        }
      });
    }

    function applyFilter(){ if (window.__TT_SQLDB__) applyFilter_DB(); else applyFilter_JSON(); }
    function resetRange(){ qs("#startInput").value=tsToLocalInput(minTs); qs("#endInput").value=tsToLocalInput(maxTs); applyFilter(); }

    function setTrackData(arr, sourceLabel){
      showLoading(t("tools.locations.parsing"));
      window.__TT_SQLDB__=null;
      if (!Array.isArray(arr)) { hideLoading(); throw new Error("array required"); }
      const cleaned=[];
      for (const p of arr){
        const ts=parseTsFlexible(p), deg=pickDegFlexible(p);
        if (!Number.isFinite(ts) || !deg) continue;
        cleaned.push({ ts: (ts<1e12?ts*1000:ts), lon_e6: Math.round(deg.lng*1e6), lat_e6: Math.round(deg.lat*1e6), __gcj: !!(p.__gcj || p.gcj) });
      }
      cleaned.sort((a,b)=>a.ts-b.ts);
      if (cleaned.length>0){ minTs=cleaned[0].ts; maxTs=cleaned[cleaned.length-1].ts; }
      else { const now=Date.now(); minTs=now-3600_000; maxTs=now; }

      const fileStatus=qs("#fileStatus");
      fileStatus.style.display="block";
      fileStatus.textContent=t("tools.locations.loaded", { source: (sourceLabel || t("tools.locations.srcInline")), n: cleaned.length });
      qs("#fileError").style.display="none";

      const s=qs("#startInput"), e=qs("#endInput");
      s.min=tsToLocalInput(minTs); s.max=tsToLocalInput(maxTs);
      e.min=tsToLocalInput(minTs); e.max=tsToLocalInput(maxTs);
      s.value=tsToLocalInput(minTs); e.value=tsToLocalInput(maxTs);

      rawTrack=cleaned;
      applyFilter();
    }

    function loadFromInlineScript(){
      const node=qs('#trackData');
      const rawText=node.textContent.trim();
      try{ setTrackData(JSON.parse(rawText||"[]"), t("tools.locations.srcInline")); }
      catch(e){ const fe=qs("#fileError"); fe.style.display="block"; fe.textContent=t("tools.locations.errInlineJSON", { msg: e.message }); hideLoading(); }
    }

    // sql.js init once
    let SQL_INIT_PROMISE=null;
    function initSqlJsOnce(){
      if (!SQL_INIT_PROMISE){
        SQL_INIT_PROMISE=initSqlJs({ locateFile:file=>`https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.10.2/${file}` });
      }
      return SQL_INIT_PROMISE;
    }

    async function loadFromSQLite(file){
      const fileError=qs("#fileError");
      const fileStatus=qs("#fileStatus");
      fileError.style.display="none"; fileStatus.style.display="none";
      showLoading(t("tools.locations.loadingDB"));
      try{
        const SQL=await initSqlJsOnce();
        const buf=new Uint8Array(await file.arrayBuffer());
        const db=new SQL.Database(buf);

        const tables=db.exec(`SELECT name FROM sqlite_master WHERE type='table'`)?.flatMap(r=>r.values.map(v=>String(v[0])))||[];
        const prefer=["location","Location","locations","userMark","frequentIndexTable","points","track","tracking"];
        let candidate=prefer.find(n=>tables.includes(n))||null;

        function tableInfo(name){ return db.exec(`PRAGMA table_info(${JSON.stringify(name)})`); }
        function colSet(info){ return new Set(info[0]?.values?.map(v=>String(v[1]))||[]); }
        function pickOne(names,cands){ for (const c of cands) if (names.has(c)) return c; return null; }

        const need = {
          ts : ["ts","timestamp","time_ms","time","ts_ms","created_at","recorded_at"],
          lon: ["lon_e6","longitude_e6","lon_e7","longitude_e7","lon","longitude","lng"],
          lat: ["lat_e6","latitude_e6","lat_e7","latitude_e7","lat","latitude"]
        };

        function findTable(){
          const tryOne=(t)=>{ const info=tableInfo(t); if(!info||info.length===0) return null;
            const names=colSet(info);
            const tsCol=pickOne(names,need.ts), lonCol=pickOne(names,need.lon), latCol=pickOne(names,need.lat);
            return (tsCol&&lonCol&&latCol)?{table:t,names,tsCol,lonCol,latCol}:null; };
          if (candidate){ const r=tryOne(candidate); if (r) return r; }
          for (const t of tables){ const r=tryOne(t); if (r) return r; }
          return null;
        }

        const found=findTable();
        if (!found) throw new Error("no table with ts/lon/lat");

        const { table, tsCol, lonCol, latCol, names } = found;

        const hasGcjLat = names.has("gcj02latitude");
        const hasGcjLon = names.has("gcj02longitude");
        const hasIsMars = names.has("isMarsLocation");

        const mm=db.exec(`SELECT MIN(${tsCol}) AS min_ts, MAX(${tsCol}) AS max_ts FROM ${table};`);
        const row=mm[0]?.values?.[0]||[];
        const rawMin = Number(row[0]);
        const rawMax = Number(row[1]);
        if (!Number.isFinite(rawMin)||!Number.isFinite(rawMax)) throw new Error("bad min/max(ts)");

        const tsIsMs = (rawMin >= 1e12 || rawMax >= 1e12);
        minTs = tsIsMs ? rawMin : rawMin * 1000;
        maxTs = tsIsMs ? rawMax : rawMax * 1000;

        window.__TT_SQLDB__={
          db, table, tsCol, lonCol, latCol,
          gcjLatCol: hasGcjLat ? "gcj02latitude"  : null,
          gcjLonCol: hasGcjLon ? "gcj02longitude" : null,
          isMarsCol: hasIsMars ? "isMarsLocation" : null,
          tsIsMs
        };

        const s=qs("#startInput"), e=qs("#endInput");
        s.min=tsToLocalInput(minTs); s.max=tsToLocalInput(maxTs);
        e.min=tsToLocalInput(minTs); e.max=tsToLocalInput(maxTs);
        s.value=tsToLocalInput(minTs); e.value=tsToLocalInput(maxTs);

        qs("#fileStatus").style.display="block";
        qs("#fileStatus").textContent=t("tools.locations.sqliteConnected", { name: file.name, table });

        applyFilter_DB();
      }catch(e){
        const fe=qs("#fileError");
        fe.style.display="block";
        fe.textContent=t("tools.locations.errSQLiteParse", { msg: e.message });
        console.error(e);
        hideLoading();
        window.__TT_SQLDB__=null;
      }
    }

    async function loadFromFile(file){
      const name=(file?.name||"").toLowerCase();
      try{
        if (name.endsWith(".json")){
          const txt = await file.text(); const json = JSON.parse(txt);
          setTrackData(json, file.name);
        } else if (name.endsWith(".db") || name.endsWith(".sqlite")){
          await loadFromSQLite(file);
        } else if (name.endsWith(".csv")){
          showLoading(t("tools.locations.loadingCSV"));
          const txt = await file.text();
          const arr = parseCSV(txt);
          setTrackData(arr, file.name);
        } else if (name.endsWith(".gpx")){
          showLoading(t("tools.locations.loadingGPX"));
          const txt = await file.text();
          const arr = parseGPX(txt);
          setTrackData(arr, file.name);
        } else if (name.endsWith(".kml")){
          showLoading(t("tools.locations.loadingKML"));
          const txt = await file.text();
          const arr = parseKML(txt);
          setTrackData(arr, file.name);
        } else {
          const txt = await file.text();
          const trimmed = txt.trim();
          if (trimmed.startsWith('{') || trimmed.startsWith('[')){
            setTrackData(JSON.parse(trimmed), file.name);
          } else if (/^\s*<\?xml|<gpx/i.test(trimmed)){
            setTrackData(parseGPX(trimmed), file.name);
          } else if (/^\s*<kml/i.test(trimmed)){
            setTrackData(parseKML(trimmed), file.name);
          } else if (trimmed.includes(',') && trimmed.split('\n')[0].includes(',')){
            setTrackData(parseCSV(trimmed), file.name);
          } else {
            throw new Error(t("tools.locations.errUnknownFormat"));
          }
        }
      }catch(e){
        const fe=qs("#fileError");
        fe.style.display="block";
        fe.textContent=t("tools.locations.errFileLoad", { msg: e.message });
        console.error(e);
        hideLoading();
      }
    }

    function setPanelCollapsed(collapsed){
      const panel=qs("#infoPanel");
      const btn=qs("#togglePanel");
      if (collapsed){
        panel.classList.add("collapsed");
        btn.textContent=t("tools.locations.unfold");
        btn.setAttribute("aria-expanded","false");
        localStorage.setItem("tt_panel_collapsed","1");
      } else {
        panel.classList.remove("collapsed");
        btn.textContent=t("tools.locations.fold");
        btn.setAttribute("aria-expanded","true");
        localStorage.setItem("tt_panel_collapsed","0");
      }
    }

    function persistOpts(){
      localStorage.setItem('tt_show_points', qs('#optShowPoints').checked ? '1' : '0');
      localStorage.setItem('tt_show_line',   qs('#optShowLine').checked ? '1' : '0');
      localStorage.setItem('tt_point_color', qs('#pointColor').value || '#5ab1ff');
    }
    function restoreOpts(){
      const sp = localStorage.getItem('tt_show_points'); if (sp!=null) qs('#optShowPoints').checked = sp==='1';
      const sl = localStorage.getItem('tt_show_line');   if (sl!=null) qs('#optShowLine').checked   = sl==='1';
      const pc = localStorage.getItem('tt_point_color'); if (pc) qs('#pointColor').value = pc;
    }

    function init(){
      map=new BMapGL.Map("map",{ enableRotate:false, enableTilt:false });
      map.centerAndZoom(new BMapGL.Point(116.404,39.915),12);
      map.addControl(new BMapGL.ZoomControl());
      map.enableScrollWheelZoom(true);

      setPanelCollapsed(localStorage.getItem("tt_panel_collapsed")==="1");
      restoreOpts();

      qs("#togglePanel").addEventListener("click",()=>{
        setPanelCollapsed(!qs("#infoPanel").classList.contains("collapsed"));
      });
      qs(".panel-header").addEventListener("dblclick", ()=>{
        setPanelCollapsed(!qs("#infoPanel").classList.contains("collapsed"));
      });

      qs("#applyBtn").addEventListener("click",()=>{ persistOpts(); applyFilter(); });
      qs("#resetBtn").addEventListener("click",()=>{ persistOpts(); resetRange(); });
      qs("#startInput").addEventListener("change",()=>{ persistOpts(); applyFilter(); });
      qs("#endInput").addEventListener("change",()=>{ persistOpts(); applyFilter(); });
      qs("#optShowPoints").addEventListener("change",()=>{ persistOpts(); applyFilter(); });
      qs("#optShowLine").addEventListener("change",()=>{ persistOpts(); applyFilter(); });
      qs("#pointColor").addEventListener("input",()=>{ persistOpts(); applyFilter(); });

      qs("#fileInput").addEventListener("change",(e)=>{ const f=e.target.files?.[0]; if (f) loadFromFile(f); });
      const dz=qs("#dropzone");
      const prevent=ev=>{ ev.preventDefault(); ev.stopPropagation(); };
      ["dragenter","dragover","dragleave","drop"].forEach(evt=>dz.addEventListener(evt,prevent,false));
      dz.addEventListener("dragenter",()=>dz.classList.add("dragover"));
      dz.addEventListener("dragover",()=>dz.classList.add("dragover"));
      dz.addEventListener("dragleave",()=>dz.classList.remove("dragover"));
      dz.addEventListener("drop",(ev)=>{ dz.classList.remove("dragover"); const f=ev.dataTransfer.files?.[0]; if (f) loadFromFile(f); });

      if (location.protocol === 'file:'){
        const fe=qs("#fileError");
        fe.style.display="block";
        fe.textContent=t("tools.locations.tipHttpServer");
      }

      loadFromInlineScript();
      applyI18nToDOM(); // 确保初始渲染文案
    }

    // 暴露调试
    window.__tt_init = init;

    // 运行初始化
    init();
  }

  /************ 异步加载百度地图后启动 ************/
  loadBMapGL({
    ak: "sUryxWWxRyHZxuzB634wHfmlqy6RgMEy", // 替换为你的 AK
    v: "1.0",
    type: "webgl",
    timeout: 15000,
    retries: 1
  }).then(() => {
    runApp();
  }).catch(err => {
    console.error(err);
    const fe = document.getElementById("fileError");
    if (fe) {
      fe.style.display = "block";
      fe.textContent = "Baidu Map GL load failed. Check network or AK.";
    }
  });
</script>
</body>
</html>
